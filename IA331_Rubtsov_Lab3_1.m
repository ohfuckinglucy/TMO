clear; clc; close all;

%% 1

% Параметры из таблицы 3.1
N = 1000;   % количество временных отсчетов
K = 1000;   % количество реализаций
mu = 20;    % математическое ожидание
sigma = 1;  % стандартное отклонение

% Генерация матрицы X: N x K, каждый элемент ~ N(mu, sigma)
X = mu + sigma * randn(N, K);

% 1. Среднее по ансамблю для каждого момента времени n
mu_ensemble = mean(X, 2);  % усреднение по второму измерению (по K)

% 2. Среднее по времени для каждой реализации k
mu_time_per_realization = mean(X, 1);  % усреднение по N
mu_time_overall = mean(mu_time_per_realization);  % среднее от средних

% 3. Построение графиков
figure('Name', 'Средние по ансамблю и по времени', 'NumberTitle', 'off');

% Среднее по ансамблю
plot(1:N, mu_ensemble, 'b-', 'LineWidth', 1.5, ...
    'DisplayName', 'Среднее по ансамблю \mu_{\xi}[n]');
hold on;

% Среднее по времени для каждой реализации
plot(1:K, mu_time_per_realization, 'g-', 'LineWidth', 0.5, ...
    'DisplayName', 'Среднее по времени для каждой реализации');

% Общее среднее
plot([1 N], [mu_time_overall mu_time_overall], 'r--', 'LineWidth', 2, ...
    'DisplayName', 'Среднее по времени (общее)');

% Теоретическое значение
plot([1 N], [mu mu], 'k:', 'LineWidth', 2, ...
    'DisplayName', 'Теоретическое \mu = 20');

xlabel('Индекс n или k');
ylabel('Значение среднего');
title('Белый гауссовский шум: среднее по ансамблю vs среднее по времени');
legend('Location', 'best');
grid on;

% 4. Вывод в командное окно
fprintf('Теоретическое среднее: %.2f\n', mu);
fprintf('Эмпирическое среднее по ансамблю (среднее по n): %.4f\n', mean(mu_ensemble));
fprintf('Эмпирическое среднее по времени (среднее по k): %.4f\n', mu_time_overall);

% 5. Вывод: эргодичность по среднему?
disp(' ');
if abs(mean(mu_ensemble) - mu_time_overall) < 0.1
    disp('ВЫВОД: Процесс выглядит эргодическим по среднему — среднее по времени близко к среднему по ансамблю.');
else
    disp('ВЫВОД: Процесс НЕ выглядит эргодическим по среднему — есть заметное расхождение.');
end

%% 2

% Выбираем три пары моментов времени (ni, nj)
pairs = [100, 101;   % соседние
         200, 500;   % далёкие
         300, 300];  % один и тот же момент

figure('Name', 'Диаграммы рассеяния для белого шума', 'NumberTitle', 'off');
for p = 1:size(pairs, 1)
    ni = pairs(p, 1);
    nj = pairs(p, 2);
    
    % Извлекаем значения по всем K реализациям
    xi_ni = X(ni, :);  % вектор длины K
    xi_nj = X(nj, :);  % вектор длины K
    
    % Рассчитываем выборочную корреляцию (коэф. Пирсона)
    r_pearson = corrcoef(xi_ni, xi_nj);
    r_pearson = r_pearson(1, 2);
    
    % Строим scatter plot
    subplot(1, 3, p);
    scatter(xi_ni, xi_nj, 10, 'filled');
    title(sprintf('n_i=%d, n_j=%d\nr̂ = %.3f', ni, nj, r_pearson));
    xlabel('\xi[n_i]');
    ylabel('\xi[n_j]');
    grid on;
    axis equal;
    
    % Выводим значение корреляции в командное окно
    fprintf('Выборочная корреляция (Пирсон) r̂(%d, %d) = %.4f\n', ni, nj, r_pearson);
end

% Теоретическое значение для ni = nj:
if any(pairs(:,1) == pairs(:,2))
    theoretical = sigma^2 + mu^2;
    fprintf('Теоретическая корреляция при ni=nj: σ² + μ² = %.0f\n', theoretical);
end

%% 3

% Параметры из Таблицы 3.2:
mu_omega = 0;    % матожидание приращения
sigma_omega = 1; % дисперсия

% Теоретическое значение: mu_xi[n] = 0 для любого n
mu_xi_n = 0;

% Вывод в командное окно
fprintf('-------------------------------------------------------------------\n');
fprintf('ЗАДАНИЕ 3: Теоретический расчёт mu_\\xi[n] для случайных блужданий\n');
fprintf('Исходные данные (Таблица 3.2): mu_\\omega = %.1f, sigma_\\omega = %.1f\n', mu_omega, sigma_omega);
fprintf('Результат: mu_\\xi[n] = %.1f (для любого n)\n', mu_xi_n);
fprintf('-------------------------------------------------------------------\n');

%% 4

% Формула: E[xi^2[n]] = n * sigma_omega^2 => sigma_xi[n] = sqrt(n)
fprintf('-------------------------------------------------------------------\n');
fprintf('ЗАДАНИЕ 4: Теоретический расчёт СКО случайного блуждания\n');
fprintf('sigma_\\omega^2 = %.1f\n', sigma_omega);
fprintf('M[\\xi^2[n]] = n * sigma_\\omega^2 = n * 1 = n\n');
fprintf('СКО: sigma_\\xi[n] = sqrt(M[\\xi^2[n]]) = sqrt(n)\n');
fprintf('При n -> ∞: sigma_\\xi[n] -> ∞ — процесс нестационарен.\n');
fprintf('-------------------------------------------------------------------\n');

%% 5

fprintf('-------------------------------------------------------------------\n');
fprintf('ЗАДАНИЕ 5: Теоретический расчёт автокорреляции случайного блуждания\n');
fprintf('Исходные данные: omega[n] ~ N(0,1), xi[0] = 0\n\n');

% 1. Автокорреляция r(n, n-1)
fprintf('1. r_\\xi(n, n-1) = E[\\xi[n] * \\xi[n-1]] = n - 1\n\n');

% 2. Обобщение на r(n, n-l)
fprintf('2. r_\\xi(n, n-l) = n - l (для l > 0, n > l)\n\n');

% 3. Стационарность
fprintf('3. Процесс НЕ стационарен в широком смысле — r зависит от n.\n\n');

% 4. Нормированный коэффициент корреляции
fprintf('4. rho_\\xi(n, n-l) = sqrt((n - l) / n) = sqrt(1 - l/n)\n\n');

% 5. Поведение при n → ∞
fprintf('5. При n → ∞ и фиксированном l: rho_\\xi(n, n-l) → 1\n');
fprintf('   (значения становятся почти полностью коррелированными)\n');
fprintf('-------------------------------------------------------------------\n');
