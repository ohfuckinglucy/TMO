clear; clc;

%% 1. Построение матрицы переходов (15x15)
L = 15;
T = zeros(L);

% - Каждый узел имеет минимум 3 исходящих маршрута
% - Каждый узел имеет хотя бы один входящий
% - Сумма каждой строки = 1 (стохастичность)

T(1, [2 3 4 5]) = [0.3, 0.3, 0.2, 0.2];
T(2, [3 6 7 8]) = [0.4, 0.2, 0.2, 0.2];
T(3, [4 9 10]) = [0.5, 0.3, 0.2];
T(4, [5 11 12]) = [0.4, 0.4, 0.2];
T(5, [6 13 14]) = [0.5, 0.3, 0.2];
T(6, [7 8 9 15]) = [0.25, 0.25, 0.25, 0.25];
T(7, [8 10 11]) = [0.4, 0.3, 0.3];
T(8, [9 12 13]) = [0.5, 0.3, 0.2];
T(9, [10 14 15]) = [0.4, 0.4, 0.2];
T(10, [11 12 13]) = [0.3, 0.4, 0.3];
T(11, [12 14]) = [0.6, 0.4];
T(12, [13 14 15]) = [0.3, 0.4, 0.3];
T(13, [1 2 3]) = [0.5, 0.3, 0.2];
T(14, [1 4 5 6]) = [0.25, 0.25, 0.25, 0.25];
T(15, [1 7 8 9]) = [0.3, 0.3, 0.2, 0.2];

% Проверка: все строки в сумме дают 1?
for i = 1:L
    if abs(sum(T(i,:)) - 1) > 1e-10
        error('Строка %d не стохастична!', i);
    end
end

%% 2. Проверка на стохастичность
if stochastic(T)
    disp('Матрица переходов T — стохастическая.');
else
    disp('Матрица переходов T — НЕ стохастическая.');
end

%% 3. Проверка на эргодичность
epsilon = 1e-5;
if ergodic(T, epsilon)
    disp('Цепь Маркова — эргодическая.');
else
    disp('Цепь Маркова — НЕ эргодическая.');
end

%% 4. Вывод матрицы
% fprintf('\nМатрица переходов T (15x15):\n');
% disp(T);

%% Функцции
function result = stochastic(matrix)
% Проверяет матрицу на стохастичность

[m, n] = size(matrix);
result = true;

for i = 1:m
    row_sum = sum(matrix(i,:));
    if abs(row_sum - 1) > 1e-10
        result = false; break;
    end
    for j = 1:n
        if matrix(i,j) < 0 || matrix(i,j) > 1
            result = false; break;
        end
    end
    if ~result, break; end
end
end

function result = ergodic(matrix, epsilon)
% Проверяет цепь Маркова на эргодичность

L = size(matrix, 1);
m = 200;
Tm = matrix^m;  % матрица переходов за m шагов

% Тест на разных начальных распределениях
initial_vectors = eye(L);  % e1=(1,0...), e2=(0,1,0...) и т.д.

result = true;
for k = 1:L
    pi0 = initial_vectors(k, :);           % начальное распределение
    pi_m = pi0 * Tm;                       % распределение через m шагов
    
    % Если есть вероятности <= epsilon → не эргодическая
    if any(pi_m <= epsilon)
        result = false;
        break;
    end
end
end